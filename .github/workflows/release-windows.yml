name: Release Windows (.exe)

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build-exe:
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install deps
        run: |
          python -m pip install -U pip
          python -m pip install -e ".[dev]"
          python -m pip install -U pyinstaller>=6.7

      - name: Test
        run: pytest

      - name: Resolve version
        id: meta
        shell: bash
        run: |
          VERSION_PY="$(python - <<'PY'
          from pathlib import Path
          import re
          text = Path("pyproject.toml").read_text(encoding="utf-8")
          m = re.search(r'^version\s*=\s*"([^"]+)"', text, re.M)
          if not m:
              raise SystemExit("version not found in pyproject.toml")
          print(m.group(1))
          PY
          )"
          if [[ "${GITHUB_REF:-}" == refs/tags/* ]]; then
            VERSION_TAG="${GITHUB_REF_NAME#v}"
            if [[ "$VERSION_TAG" != "$VERSION_PY" ]]; then
              echo "Tag version ($VERSION_TAG) does not match pyproject version ($VERSION_PY)" >&2
              exit 1
            fi
            VERSION="$VERSION_TAG"
          else
            VERSION="$VERSION_PY"
          fi
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"

      - name: Build exe with PyInstaller
        id: exe
        shell: bash
        run: |
          mkdir -p build/windows_exe

          # Build single-file executable
          pyinstaller \
            --onefile \
            --name berry \
            --distpath build/windows_exe/dist \
            --workpath build/windows_exe/work \
            --specpath build/windows_exe \
            --clean \
            scripts/pyinstaller_entry.py

          EXE_PATH="build/windows_exe/dist/berry.exe"
          if [[ ! -f "$EXE_PATH" ]]; then
            echo "Expected exe not found: $EXE_PATH" >&2
            exit 1
          fi

          # Rename with version
          VERSION="${{ steps.meta.outputs.version }}"
          FINAL_NAME="berry-${VERSION}-windows-x64.exe"
          mv "$EXE_PATH" "build/windows_exe/dist/$FINAL_NAME"

          echo "exe_path=build/windows_exe/dist/$FINAL_NAME" >> "$GITHUB_OUTPUT"
          echo "exe_name=$FINAL_NAME" >> "$GITHUB_OUTPUT"

      - name: Validate exe runs
        shell: pwsh
        run: |
          $exe = "${{ steps.exe.outputs.exe_path }}"
          Write-Host "Testing exe: $exe"
          & $exe version
          if ($LASTEXITCODE -ne 0) {
            Write-Error "Exe validation failed"
            exit 1
          }
          Write-Host "Exe validation passed"

      - uses: actions/upload-artifact@v4
        with:
          name: berry-exe-x64
          path: ${{ steps.exe.outputs.exe_path }}
          if-no-files-found: error

  publish:
    runs-on: ubuntu-latest
    needs: [build-exe]
    if: startsWith(github.ref, 'refs/tags/')
    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Compute checksums
        id: sums
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          EXE="$(find artifacts -type f -name "*.exe" | head -n1)"
          if [[ -z "$EXE" ]]; then
            echo "Missing exe artifact" >&2
            find artifacts -type f -maxdepth 4 -print >&2 || true
            exit 1
          fi
          SHA_EXE="$(sha256sum "$EXE" | awk '{print $1}')"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "sha_x64=$SHA_EXE" >> "$GITHUB_OUTPUT"
          echo "exe_path=$EXE" >> "$GITHUB_OUTPUT"

      - name: Create / update GitHub release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            ${{ steps.sums.outputs.exe_path }}
          generate_release_notes: true
          append_body: |

            ## Windows

            **SHA256:** `${{ steps.sums.outputs.sha_x64 }}`

            > ⚠️ Windows SmartScreen may show a warning for unsigned executables.
            > This is expected for open-source software without code signing.
